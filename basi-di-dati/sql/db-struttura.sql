--CREAZIONE SEQUENCE (AUTOINCREMENT PER GENERAZIONE AUTOMATICA DI ID)

--SEQUENCE: GENERA ID PER LABORATORIO
CREATE SEQUENCE genera_id_lab
  START WITH 1
  INCREMENT BY 1
  MINVALUE 1
  NOCACHE;

--SEQUENCE: GENERA ID PER SEDE
CREATE SEQUENCE genera_id_sede
  START WITH 1
  INCREMENT BY 1
  MINVALUE 1
  NOCACHE;

--SEQUENCE: GENERA ID PER POSTAZIONE
CREATE SEQUENCE genera_id_post
  START WITH 1
  INCREMENT BY 1
  MINVALUE 1
  NOCACHE;

--SEQUENCE: GENERA ID PER STRUMENTO
CREATE SEQUENCE genera_id_strum
  START WITH 1
  INCREMENT BY 1
  MINVALUE 1
  NOCACHE;

--SEQUENCE: GENERA ID PER PRENOTAZIONE
CREATE SEQUENCE genera_id_pren
  START WITH 1
  INCREMENT BY 1
  MINVALUE 1
  NOCACHE;










--CREAZIONE TABELLE

--TABLE: LABORATORIO
CREATE TABLE LABORATORIO(
    ID_LAB INTEGER DEFAULT ON NULL genera_id_lab.NEXTVAL PRIMARY KEY,
    NOME VARCHAR2(50) NOT NULL,
    ANNOFONDAZIONE NUMBER(4, 0) NOT NULL,
    CAMPO VARCHAR2(50) DEFAULT ON NULL 'Sconosciuto' NOT NULL,
    DESCRIZIONE VARCHAR2(250) DEFAULT ON NULL 'Descrizione non presente' NOT NULL 
);

--TABLE: SEDE
CREATE TABLE SEDE(
    ID_SEDE INTEGER DEFAULT ON NULL genera_id_sede.NEXTVAL PRIMARY KEY,
    INDIRIZZO VARCHAR2(100) NOT NULL,
    ID_LAB INTEGER NOT NULL,
    --FOREIGN KEY
    CONSTRAINT sede_fk FOREIGN KEY (ID_LAB) REFERENCES LABORATORIO(ID_LAB) ON DELETE CASCADE
);

--TABLE: POSTAZIONE
CREATE TABLE POSTAZIONE(
    ID_POSTAZIONE INTEGER DEFAULT ON NULL genera_id_post.NEXTVAL PRIMARY KEY,
    NOME CHAR(2) NOT NULL,
    ID_SEDE INTEGER NOT NULL,
    --FOREIGN KEY    
    CONSTRAINT postazione_fk FOREIGN KEY (ID_SEDE) REFERENCES SEDE(ID_SEDE) ON DELETE CASCADE,
    --VINCOLO UNIQ_POST_NOME
    CONSTRAINT uniq_post_nome UNIQUE (NOME, ID_SEDE),
    --VINCOLO VALID_POST_NOME
    CONSTRAINT valid_post_nome CHECK (REGEXP_LIKE(NOME, '^[A-Z][1-9]$'))
);

--TABLE: STRUMENTO
CREATE TABLE STRUMENTO(
    ID_STRUMENTO INTEGER DEFAULT ON NULL genera_id_strum.NEXTVAL PRIMARY KEY,
    DESCRIZIONE VARCHAR2(75) NOT NULL,
    SCHEDATECNICA VARCHAR2(250) DEFAULT ON NULL'Scheda tecnica non presente' NOT NULL,
    ID_POSTAZIONE INTEGER,
    --FOREIGN KEY
    CONSTRAINT strumento_fk FOREIGN KEY (ID_POSTAZIONE) REFERENCES POSTAZIONE(ID_POSTAZIONE) ON DELETE SET NULL
);

--TABLE: RESPONSABILE
CREATE TABLE RESPONSABILE(
    MATRICOLA CHAR(10) PRIMARY KEY,
    NOME VARCHAR2(50) NOT NULL,
    COGNOME VARCHAR2(50) NOT NULL,
    DATANASCITA DATE NOT NULL,
    CODICEFISCALE CHAR(16) NOT NULL,
    INDIRIZZO VARCHAR(100) NOT NULL,
    TELEFONO1 CHAR(10) NOT NULL,
    TELEFONO2 CHAR(10),
    EMAIL VARCHAR(100) NOT NULL,
    ID_SEDE INTEGER NOT NULL UNIQUE,
    --FOREIGN KEY
    CONSTRAINT responsabile_fk FOREIGN KEY (ID_SEDE) REFERENCES SEDE(ID_SEDE),
    --VINCOLO VALID_MATR
    CONSTRAINT valid_matr_r CHECK (REGEXP_LIKE(MATRICOLA, '^R[0-9]{9}$')),
    --VINCOLO VALID_TEL
    CONSTRAINT valid_tel1_r CHECK (REGEXP_LIKE(TELEFONO1, '^[0-9]{10}$')),
    CONSTRAINT valid_tel2_r CHECK (REGEXP_LIKE(TELEFONO2, '^[0-9]{10}$')),
    --VINCOLO VALID_CF
    CONSTRAINT valid_cf_r CHECK (REGEXP_LIKE(CODICEFISCALE, '^[A-Z]{6}[0-9]{2}[A-Z][0-9]{2}[A-Z][0-9]{3}[A-Z]$')),
    --VINCOLO VALID_EMAIL
    CONSTRAINT valid_email_r CHECK (EMAIL LIKE '_%@_%.__%')
);

--TABLE: TECNICO
CREATE TABLE TECNICO(
    MATRICOLA CHAR(10) PRIMARY KEY,
    NOME VARCHAR2(50) NOT NULL,
    COGNOME VARCHAR2(50) NOT NULL,
    DATANASCITA DATE NOT NULL,
    CODICEFISCALE CHAR(16)NOT NULL,
    INDIRIZZO VARCHAR(100) NOT NULL,
    TELEFONO1 CHAR(10) NOT NULL,
    TELEFONO2 CHAR(10),
    EMAIL VARCHAR(100) NOT NULL,
    ID_SEDE INTEGER NOT NULL,
    --FOREIGN KEY
    CONSTRAINT tecnico_fk FOREIGN KEY (ID_SEDE) REFERENCES SEDE(ID_SEDE),
    --VINCOLO VALID_MATR
    CONSTRAINT valid_matr_t CHECK (REGEXP_LIKE(MATRICOLA, '^T[0-9]{9}$')),
    --VINCOLO VALID_TEL
    CONSTRAINT valid_tel1_t CHECK (REGEXP_LIKE(TELEFONO1, '^[0-9]{10}$')),
    CONSTRAINT valid_tel2_t CHECK (REGEXP_LIKE(TELEFONO2, '^[0-9]{10}$')),
    --VINCOLO VALID_CF
    CONSTRAINT valid_cf_t CHECK (REGEXP_LIKE(CODICEFISCALE, '^[A-Z]{6}[0-9]{2}[A-Z][0-9]{2}[A-Z][0-9]{3}[A-Z]$')),
    --VINCOLO VALID_EMAIL
    CONSTRAINT valid_mail_t CHECK (EMAIL LIKE '_%@_%.__%')
);

--TABLE: UTENTE
CREATE TABLE UTENTE(
    USERNAME VARCHAR(18) PRIMARY KEY,
    USR_PASSWORD RAW(200) NOT NULL,
    EMAIL VARCHAR(100) NOT NULL,
    --VINCOLO VALID_EMAIL
    CONSTRAINT valid_email_usr CHECK (EMAIL LIKE '_%@_%.__%'),
    --VINCOLO VALID_USERNAME
    CONSTRAINT valid_username CHECK (REGEXP_LIKE(USERNAME, '[a-zA-Z0-9]{6}.*')),
    --VINCOLO UNNIQ_EMAIL
    CONSTRAINT uniq_email UNIQUE(EMAIL)
);

--TABLE: PRENOTAZIONE
CREATE TABLE PRENOTAZIONE(
    ID_PRENOTAZIONE INTEGER DEFAULT ON NULL genera_id_pren.NEXTVAL PRIMARY KEY,
    DATAINIZIO DATE NOT NULL,
    DURATA INTEGER NOT NULL,
    DATAPRENOTAZIONE DATE DEFAULT ON NULL SYSDATE NOT NULL,
    ID_STRUMENTO INTEGER NOT NULL,
    USERNAME VARCHAR(18) NOT NULL,
    --FOREIGN KEY
    CONSTRAINT prenotazione_fk_strumento FOREIGN KEY (ID_STRUMENTO) REFERENCES STRUMENTO(ID_STRUMENTO),
    CONSTRAINT prenotazione_fk_utente FOREIGN KEY (USERNAME) REFERENCES UTENTE(USERNAME),
    --VINCOLO VALID_PREN_DURATA
    CONSTRAINT valid_pren_durata CHECK(DURATA BETWEEN 1 AND 24),
    --VINCOLO VALID_PREN_INIZIO
    CONSTRAINT valid_pren_inizio CHECK(DATAINIZIO > DATAPRENOTAZIONE)
);










--CREAZIONE FUNZIONI E PROCEDURE

--FUNCTION: CRITTOGRAFA LA PASSWORD UTILIZZANDO L'ALGORITMO AES128
CREATE OR REPLACE FUNCTION encrypt_pwd(pwd VARCHAR2)
RETURN RAW AS
chiave RAW(16) := '1234567890123456';
modulo NUMBER := DBMS_CRYPTO.ENCRYPT_AES128 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5;
encrypted_raw RAW(2000);
l_return RAW(2000);
BEGIN
    encrypted_raw := DBMS_CRYPTO.ENCRYPT(UTL_I18N.STRING_TO_RAW(pwd, 'AL32UTF8'), modulo, UTL_I18N.STRING_TO_RAW(chiave, 'AL32UTF8'));
    DBMS_OUTPUT.PUT_LINE('Password crittografata:' || encrypted_raw);
    RETURN encrypted_raw;
END encrypt_pwd;
/

--FUNCTION: DECRIPTA LA PASSWORD
CREATE OR REPLACE FUNCTION decrypt_pwd(pwd RAW)
RETURN VARCHAR2 AS
chiave RAW(16) := '1234567890123456';
modulo NUMBER := DBMS_CRYPTO.ENCRYPT_AES128 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5;
decrypted_raw RAW(2000);
decrypted_pwd VARCHAR2(2000);
BEGIN
    decrypted_raw := DBMS_CRYPTO.DECRYPT (pwd, modulo, UTL_I18N.STRING_TO_RAW(chiave, 'AL32UTF8'));
    decrypted_pwd :=  UTL_RAW.CAST_TO_VARCHAR2(decrypted_raw);
    DBMS_OUTPUT.PUT_LINE ('Password decriptata:' || decrypted_pwd);
    RETURN decrypted_pwd;
END decrypt_pwd;
/

--FUNCTION: CONTROLLA LE CREDENZIALI DURANTE IL LOGIN
CREATE OR REPLACE FUNCTION autenticazione(usrname UTENTE.USERNAME%TYPE, pwd VARCHAR2)
RETURN BOOLEAN AS
tmp UTENTE.USERNAME%TYPE;
BEGIN
SELECT USERNAME INTO tmp
FROM UTENTE
WHERE UPPER(usrname) = UTENTE.USERNAME AND decrypt_pwd(UTENTE.USR_PASSWORD) = LTRIM(RTRIM(pwd));
RETURN TRUE;
EXCEPTION
WHEN NO_DATA_FOUND THEN
RETURN FALSE;
END autenticazione;
/

--FUNCTION: CONTROLLA SE LA PASSWORD RISPETTA IL VINCOLO VALID_PW
CREATE OR REPLACE FUNCTION controlla_pw (pw VARCHAR2)
RETURN BOOLEAN AS
BEGIN
    IF(REGEXP_INSTR(pw, '[[:digit:]]')>=1 AND REGEXP_LIKE(pw, '\w{5,}') AND NOT REGEXP_LIKE(pw, '[[:blank:]]'))
    THEN
    RETURN TRUE;
    ELSE
    RETURN FALSE;
    END IF;
END controlla_pw;
/










--CREAZIONE TRIGGER

--TRIGGER: IMPLEMENTA IL VINCOLO NO_OVERLAP_PREN
CREATE OR REPLACE TRIGGER no_overlap_pren
BEFORE INSERT ON PRENOTAZIONE
FOR EACH ROW
DECLARE
    strumento_prenotato EXCEPTION;
    CURSOR curr IS
    SELECT P.DATAINIZIO, P.DURATA
    FROM PRENOTAZIONE P
    WHERE P.ID_STRUMENTO = :NEW.ID_STRUMENTO
    ORDER BY DATAINIZIO ASC;
    c curr%ROWTYPE;
BEGIN
    OPEN curr;
    LOOP
        FETCH curr INTO c;
        EXIT WHEN curr%NOTFOUND;
        IF((:NEW.DATAINIZIO BETWEEN c.DATAINIZIO AND c.DATAINIZIO+(1/24*c.DURATA))
            OR
           (:NEW.DATAINIZIO+(1/24*:NEW.DURATA) BETWEEN c.DATAINIZIO AND c.DATAINIZIO+(1/24*c.DURATA)))
        THEN
            RAISE strumento_prenotato;
        END IF;
    END LOOP;
    CLOSE curr;
EXCEPTION
    WHEN strumento_prenotato THEN
        RAISE_APPLICATION_ERROR(-20004, 'Strumento giï¿½ prenotato');
END no_overlap_pren;
/

--TRIGGER: IMPLEMENTA IL VINCOLO DELETE_OR_MODIFY_PREN
CREATE OR REPLACE TRIGGER delete_or_modify_pren
BEFORE DELETE OR UPDATE ON PRENOTAZIONE
FOR EACH ROW
DECLARE
    curr_date DATE;
    modifica_non_valida EXCEPTION;
    elim_non_valida EXCEPTION;
BEGIN

    curr_date := SYSDATE;
    
    IF(:OLD.DATAINIZIO <= curr_date) THEN
        IF DELETING THEN
            RAISE elim_non_valida;
        END IF;
        IF UPDATING THEN
            RAISE modifica_non_valida;
        END IF;
    END IF;
    
EXCEPTION
    WHEN modifica_non_valida THEN
        RAISE_APPLICATION_ERROR(-20001, 'Impossibile modificare prenotazione passata');
    WHEN elim_non_valida THEN
        RAISE_APPLICATION_ERROR(-20002, 'Impossibile eliminare prenotazione passata');
END delete_or_modify_pren;
/


--TRIGGER: IMPLEMENTA IL VINCOLO VALID_PW ED ESEGUE LA CRITTOGRAFIA DELLA PASSWORD
CREATE OR REPLACE TRIGGER inserisci_pw
BEFORE INSERT ON UTENTE
FOR EACH ROW
DECLARE
password_non_valida EXCEPTION;
psswd VARCHAR2(1000);
BEGIN
    psswd := UTL_RAW.CAST_TO_VARCHAR2(:NEW.USR_PASSWORD);
    IF(controlla_pw(psswd))
    THEN
    :NEW.USR_PASSWORD := encrypt_pwd(psswd);
    ELSE
    RAISE password_non_valida;
    END IF;
    EXCEPTION
    WHEN password_non_valida THEN
    RAISE_APPLICATION_ERROR(-20003, 'La password non rispetta i criteri');
END inserisci_pw;
/









--CREAZIONE VISTE

--VIEW: RIEPILOGO










ALTER SESSION SET NLS_DATE_FORMAT = 'DD/MM/YYYY hh24:mi';

COMMIT;

